# Automated CI/CD Pipeline for DashDice Matchmaking System
# Comprehensive deployment automation with environment management

name: DashDice Production Deploy

on:
  push:
    branches: [main, production]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      run_tests:
        description: 'Run full test suite'
        required: false
        default: true
        type: boolean

permissions:
  contents: read
  security-events: write
  actions: read
  packages: write

env:
  NODE_VERSION: '18'
  GO_VERSION: '1.21'
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  # Pre-deployment validation
  validate:
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      environment: ${{ steps.check.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate deployment conditions
        id: check
        run: |
          # Determine target environment
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/production" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi
          
          # Check if we should deploy
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          fi

      - name: Environment summary
        run: |
          echo "üöÄ Deployment Configuration:"
          echo "Environment: ${{ steps.check.outputs.environment }}"
          echo "Should Deploy: ${{ steps.check.outputs.should_deploy }}"
          echo "Event: ${{ github.event_name }}"
          echo "Branch: ${{ github.ref }}"

  # Code quality and testing
  test:
    runs-on: ubuntu-latest
    needs: validate
    if: ${{ github.event.inputs.run_tests != 'false' }}
    strategy:
      matrix:
        test-type: [frontend]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        if: matrix.test-type == 'frontend' || matrix.test-type == 'integration'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Setup Go
        if: matrix.test-type == 'backend' || matrix.test-type == 'integration'
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Install Node dependencies
        if: matrix.test-type == 'frontend' || matrix.test-type == 'integration'
        run: npm ci

      - name: Install Go dependencies
        if: matrix.test-type == 'backend' || matrix.test-type == 'integration'
        working-directory: ./go-services
        run: |
          for service in api-gateway match-service queue-service presence-service notification-service; do
            cd $service && go mod download && cd ..
          done

      - name: Setup test environment
        run: |
          # Create test environment files
          cp .env.example .env.test
          echo "ENVIRONMENT=test" >> .env.test
          echo "REDIS_URL=redis://localhost:6379" >> .env.test
          echo "POSTGRES_URL=postgres://test:test@localhost:5432/test" >> .env.test

      - name: Start test services
        if: matrix.test-type == 'integration'
        run: |
          docker compose -f go-services/docker-compose.yml up -d redis postgres
          sleep 10 # Wait for services to be ready

      - name: Run Frontend Tests
        if: matrix.test-type == 'frontend'
        run: |
          npm run lint
          npm run type-check
          npm run test:unit
          npm run build

      - name: Run Backend Tests
        if: matrix.test-type == 'backend'
        working-directory: ./go-services
        run: |
          # Test each microservice
          for service in api-gateway match-service queue-service presence-service notification-service; do
            echo "Testing $service..."
            cd $service
            go test -v ./... -race -coverprofile=coverage.out
            cd ..
          done

      - name: Run Integration Tests
        if: matrix.test-type == 'integration'
        run: |
          # Wait for services to be fully ready
          timeout 60 bash -c 'until docker compose -f go-services/docker-compose.yml exec redis redis-cli ping; do sleep 2; done'
          
          # Run comprehensive integration tests
          powershell -File integration-check-simple.ps1 -Detailed
          powershell -File test-websocket.ps1
          powershell -File advanced-load-testing.ps1 -TestType integration -ConcurrentUsers 10 -Duration 30

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.test-type }}
          path: |
            test-results/
            coverage.out
            *-test-report-*.txt

  # Security scanning
  security:
    runs-on: ubuntu-latest
    needs: validate
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'

      - name: NPM audit
        run: |
          npm audit --audit-level moderate || echo "NPM audit found vulnerabilities"
          npm audit fix --dry-run || echo "NPM audit fix dry-run completed"

  # Build and package
  build:
    runs-on: ubuntu-latest
    needs: [validate, test, security]
    if: needs.validate.outputs.should_deploy == 'true'
    strategy:
      matrix:
        component: [frontend]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Frontend
        if: matrix.component == 'frontend'
        run: |
          # Setup Node.js
          curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
          sudo apt-get install -y nodejs
          
          # Install dependencies and build
          npm ci
          npm run build
          
          # Create deployment artifact
          tar -czf frontend-build.tar.gz .next/ public/ package.json

      - name: Build Microservices
        if: matrix.component == 'microservices'
        working-directory: ./go-services
        run: |
          # Build all microservices
          services=(api-gateway match-service queue-service presence-service notification-service)
          
          for service in "${services[@]}"; do
            echo "Building $service..."
            docker build -t ghcr.io/${{ github.repository }}/$service:${{ github.sha }} -f $service/Dockerfile .
            docker push ghcr.io/${{ github.repository }}/$service:${{ github.sha }}
          done

      - name: Build WebSocket Server
        if: matrix.component == 'websocket'
        run: |
          docker build -t ghcr.io/${{ github.repository }}/websocket-server:${{ github.sha }} -f Dockerfile.websocket .
          docker push ghcr.io/${{ github.repository }}/websocket-server:${{ github.sha }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ matrix.component }}-${{ github.sha }}
          path: |
            frontend-build.tar.gz
            docker-compose.yml
            .env.example

  # Deploy to Vercel (Frontend)
  deploy-frontend:
    runs-on: ubuntu-latest
    needs: [validate, build]
    if: needs.validate.outputs.should_deploy == 'true'
    environment: 
      name: ${{ needs.validate.outputs.environment }}
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-frontend-${{ github.sha }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Deploy to Vercel
        id: deploy
        run: |
          # Set environment-specific variables
          if [[ "${{ needs.validate.outputs.environment }}" == "production" ]]; then
            VERCEL_ENV="production"
            VERCEL_PROJECT_ID="${{ secrets.VERCEL_PROJECT_ID }}"
            VERCEL_ORG_ID="${{ secrets.VERCEL_ORG_ID }}"
          else
            VERCEL_ENV="preview"
            VERCEL_PROJECT_ID="${{ secrets.VERCEL_STAGING_PROJECT_ID }}"
            VERCEL_ORG_ID="${{ secrets.VERCEL_ORG_ID }}"
          fi
          
          # Deploy to Vercel
          vercel deploy \
            --token="${{ secrets.VERCEL_TOKEN }}" \
            --env NEXT_PUBLIC_API_URL="${{ secrets.API_URL }}" \
            --env NEXT_PUBLIC_WEBSOCKET_URL="${{ secrets.WEBSOCKET_URL }}" \
            --env FIREBASE_ADMIN_KEY="${{ secrets.FIREBASE_ADMIN_KEY }}" \
            --env REDIS_URL="${{ secrets.REDIS_URL }}" \
            --prod=$([[ "$VERCEL_ENV" == "production" ]] && echo "true" || echo "false")

      - name: Get deployment URL
        run: |
          DEPLOY_URL=$(vercel ls --token="${{ secrets.VERCEL_TOKEN }}" --scope="${{ secrets.VERCEL_ORG_ID }}" | grep -E "https://.*\.vercel\.app" | head -1 | awk '{print $1}')
          echo "url=$DEPLOY_URL" >> $GITHUB_OUTPUT
          echo "üöÄ Deployed to: $DEPLOY_URL"

  # Deploy Infrastructure (Microservices) - Disabled for now
  # deploy-infrastructure:
  #   runs-on: ubuntu-latest
  #   needs: [validate, build]
  #   if: needs.validate.outputs.should_deploy == 'true'
  #   environment: ${{ needs.validate.outputs.environment }}
  #   steps:
  #     - name: Skip infrastructure deployment
  #       run: echo "Infrastructure deployment skipped - frontend only"

  # Post-deployment validation
  post-deploy:
    runs-on: ubuntu-latest
    needs: [validate, deploy-frontend]
    if: needs.validate.outputs.should_deploy == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for deployment stabilization
        run: sleep 60

      - name: Run post-deployment health checks
        run: |
          echo "üè• Running basic health checks..."
          
          # Wait for Vercel deployment to be fully ready
          sleep 30
          
          # Test frontend accessibility
          FRONTEND_URL="https://dashdice.vercel.app"
          echo "Testing $FRONTEND_URL"
          
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$FRONTEND_URL" || echo "000")
          echo "HTTP Status Code: $HTTP_CODE"
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Frontend is accessible"
          else
            echo "‚ö†Ô∏è Frontend returned status code: $HTTP_CODE (may still be deploying)"
          fi

  # Rollback capability
  rollback:
    runs-on: ubuntu-latest
    needs: [post-deploy]
    if: failure() && needs.validate.outputs.should_deploy == 'true'
    environment: ${{ needs.validate.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Rollback deployment
        run: |
          echo "üîÑ Rolling back deployment due to failures..."
          
          # Rollback Vercel deployment (if VERCEL_TOKEN is configured)
          if [ -n "${{ secrets.VERCEL_TOKEN }}" ]; then
            vercel rollback --token="${{ secrets.VERCEL_TOKEN }}" --yes || echo "Rollback command executed"
          else
            echo "‚ö†Ô∏è VERCEL_TOKEN not configured, manual rollback may be required"
          fi

  # Notification and reporting
  notify:
    runs-on: ubuntu-latest
    needs: [validate, post-deploy]
    if: always() && needs.validate.outputs.should_deploy == 'true'

    steps:
      - name: Deployment notification
        run: |
          STATUS="${{ job.status }}"
          ENVIRONMENT="${{ needs.validate.outputs.environment }}"
          
          if [[ "$STATUS" == "success" ]]; then
            EMOJI="‚úÖ"
            MESSAGE="Deployment to $ENVIRONMENT completed successfully!"
          else
            EMOJI="‚ùå"
            MESSAGE="Deployment to $ENVIRONMENT failed!"
          fi
          
          echo "$EMOJI $MESSAGE"
          
          # Send notification to team (Slack, Discord, etc.)
          # curl -X POST -H 'Content-type: application/json' \
          #   --data "{\"text\":\"$EMOJI DashDice $MESSAGE\"}" \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Update deployment status
        if: always()
        run: |
          # Update GitHub deployment status
          echo "Deployment status: ${{ job.status }}"
          echo "Environment: ${{ needs.validate.outputs.environment }}"
          echo "Commit: ${{ github.sha }}"
